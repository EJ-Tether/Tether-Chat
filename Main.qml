// Begin source file Main.qml
import QtQuick
import QtQuick.Controls
import QtQuick.Layouts
import QtQuick.Dialogs
import Tether 1.0

ApplicationWindow {
    id: _root
    visible: true
    // La fenêtre s'élargit à 1360 dès qu'au moins une image de personnage est active
    property bool hasImages: (_chatManager.activeInterlocutorImagePath1 !== "") || (_chatManager.activeInterlocutorImagePath2 !== "")
    width: hasImages ? 1360 : 960
    height: 800
    Behavior on width { NumberAnimation { duration: 200; easing.type: Easing.InOutQuad } }

    // Custom colors
    property color humanMessageColor: "#fff8e1"  // pale yellow
    property color aiMessageColor: "#e3f2fd"     // pale blue
    property color borderColor: "#E0E0E0"
    property color sendButtonColor: "#2196F3"

    property var currentChatModel: _chatManager.chatModel

    // Fonction pour envoyer le message
    function sendMessage() {
        var text = messageInput.text.trim();
        if (text.length > 0) {
            currentChatModel.sendMessage(text);
            messageInput.text = "";
        }
    }



    // 1._headerChatareaDivide: separates vertically the main window in two parts: the banner
    // containing the Tab bar on top, and the main area in the rest of the window. The nature
    // of the main area is defined by the active tab: either chat area, or configuration form,
    // or "about/help/licence informations"
    ColumnLayout {
        id: _headerChatareaDivide
        anchors.fill: parent
        width: parent.width
        height: parent.height
        // 1.1 `_menuBar` : Manages the TAB bar and other buttons for the application controls
        // (common to all pages).
        RowLayout {
            id: _menuBar
            implicitHeight: 40
            width: parent.width
            TabBar {
                id: _tabBar
                currentIndex: 0

                TabButton {
                    font.bold: checked
                    text: qsTr("Chat")
                    width: implicitWidth
                }
                TabButton {
                    font.bold: checked
                    text: qsTr("Configure")
                    width: implicitWidth
                }
                TabButton {
                    font.bold: checked
                    text: qsTr("About")
                    width: implicitWidth
                }
            }
            Item {
                Layout.fillWidth: true
            }
            Label {
                text: "Session cost: " + (_chatManager.chatModel ? (_chatManager.chatModel.cumulativeTokenCost + " tokens"): "")
            }
            CheckBox {
                id: extendedContextCheckbox
                text: "Extended context (no files)"
                checked: _chatManager.chatModel ? _chatManager.chatModel.extendedContextEnabled : false
                onCheckedChanged: {
                    if (_chatManager.chatModel)
                        _chatManager.chatModel.extendedContextEnabled = checked
                }
            }
            Button {
                id: _displayLicence
                visible: _tabBar.currentIndex === 2
                text: qsTr("Display Licence")
                height: 40
                width:80
                onClicked: {
                    // _debugLogs.open() // Si vous voulez toujours l'utiliser pour la licence
                }
            }
            ComboBox {
                id: languageSelector
                width: 240
                height: 40
                model: [ "English", "Français"]
                displayText: _settings?model[_settings.language]:"#####"
                currentIndex : 0
                onCurrentIndexChanged: {
                    if (_settings.changingLanguage) {
                        // We're currently loading the new current language.
                        // This is a false event generated by engine.retranslate(),
                        // we must ignore it
                        return;
                    }
                    _settings.language = currentIndex ;
                }
            }
            ComboBox {
                id: interlocutorSelector
                model: _chatManager.interlocutorNames // Le ComboBox se remplit automatiquement
                currentIndex: model.indexOf(_chatManager.activeInterlocutorName) // Sélectionne l'actif

                onActivated: (index) => {
                                 // Quand l'utilisateur choisit, on appelle le manager
                                 _chatManager.switchToInterlocutor(interlocutorSelector.model[index])
                             }
            }
            Item {
                width:40
            }
        }

        // 1.2 `_mainArea` : manages the different version of the main area (chat, configuration, about, ...)
        StackLayout {
            id: _mainArea
            currentIndex: _tabBar.currentIndex
            Layout.fillWidth: true
            Layout.fillHeight: true
            Layout.alignment: Qt.AlignHCenter

            // 1.2.1 `_chatArea` : Chat Window content + optional image side-panel
            RowLayout {
                id: _chatAreaRow
                Layout.fillWidth: true
                Layout.fillHeight: true
                spacing: 0

            // Chat column
            ColumnLayout {
                id: _chatArea
                Layout.fillHeight: true
                Layout.fillWidth: true


                Rectangle {
                    id: _messagesArea
                    Layout.fillWidth: true
                    Layout.fillHeight: true
                    color: "#FAFAFA"
                    ColumnLayout {
                        id: _messageColumn
                        anchors.fill: parent
                        spacing: 0

                        // Zone des messages (ListView)
                        ListView {
                            id: _messageListView
                            Layout.fillWidth: true
                            Layout.fillHeight: true
                            Layout.margins: 10
                            spacing: 15
                            clip: true
                            verticalLayoutDirection: ListView.TopToBottom
                            model: _chatManager.chatModel
                            Component.onCompleted: {
                                // On demande à la vue de se positionner à la fin de son contenu.
                                positionViewAtEnd()
                            }
                            Connections {
                                target: _chatManager.chatModel
                                function onModelReset() { Qt.callLater(_messageListView.positionViewAtEnd); }
                                function onChatMessageAdded() { _messageListView.positionViewAtEnd(); }
                            }
                            ScrollBar.vertical: ScrollBar {
                                policy: ScrollBar.AsNeeded
                            }

                            delegate: Item {
                                id: _singleMessageArea
                                // _singleMessageArea : is the invisible rectangle occupying the full
                                // width of the window and as high as the message. Inside this
                                // invisible placeholder we'll display the message bubble, aka the rounded
                                // rectangle on 80% of the width aligned left or right with the text in it.
                                Layout.preferredWidth: _messageListView.width
                                Layout.preferredHeight: _messageBubble.height
                                implicitHeight: _messageBubble.height
                                implicitWidth: _messageListView.width
                                Rectangle {
                                    id: _messageBubble
                                    // _messageBubble: the visible rectangle with rounded corners with
                                    // the message inside.
                                    visible: !model.isTypingIndicator
                                    width: Math.min(_messageText.implicitWidth + 20, parent.width * 0.8)
                                    height: _messageText.implicitHeight + 20
                                    radius: 12
                                    border.width: 1
                                    border.color: borderColor
                                    color: model.isError ? "#ffcdd2" : (model.isLocalMessage ? humanMessageColor : aiMessageColor)
                                    anchors.top: parent.top
                                    anchors.left: model.isLocalMessage ? parent.left : undefined // Ancre à gauche si humain
                                    anchors.right: model.isLocalMessage ? undefined : parent.right // Ancre à droite si IA

                                    TextEdit {
                                        id: _messageText
                                        anchors.fill: parent
                                        textFormat: Text.MarkdownText
                                        anchors.margins: 10
                                        text: model.text
                                        wrapMode: Text.Wrap
                                        font.pixelSize: 14
                                        color: "#333333"
                                        readOnly: true
                                        selectByMouse: true
                                        // Définir une largeur maximale pour que implicitHeight soit calculé correctement
                                        width: parent.width - 20 // 20 pour les marges du parent (messageBubble)
                                    }

                                    // Bouton Copier (visible au survol ou toujours)
                                    Button {
                                        id: copyButton
                                        text: "⎘" // Ou une icône si disponible
                                        width: 15
                                        height: 30
                                        z:1
                                        visible: false
                                        anchors.top: parent.top
                                        anchors.right: parent.right
                                        anchors.rightMargin: 25
                                        anchors.topMargin: 5
                                        background: Rectangle {
                                            color: "#ffffff"
                                            radius: 6
                                            opacity: 0.8
                                            border.color: "#cccccc"
                                            z:-1
                                        }
                                        onClicked: {
                                            _chatManager.copyToClipboard(model.text)
                                        }
                                    }

                                    MouseArea {
                                        anchors.fill: parent
                                        hoverEnabled: true
                                        acceptedButtons: Qt.NoButton // Laisser passer les clics pour la sélection
                                        cursorShape: Qt.IBeamCursor
                                        onEntered: copyButton.visible = true
                                        onExited: copyButton.visible = false
                                    }
                                }
                                Item {
                                    id: typingIndicator
                                    visible: model.isTypingIndicator
                                    width: 80
                                    height: 40
                                    // Ancré à gauche comme un message de l'IA
                                    anchors.left: parent.left
                                    anchors.leftMargin: 10

                                    RowLayout {
                                        anchors.verticalCenter: parent.verticalCenter
                                        spacing: 5

                                        Repeater {
                                            model: 3 // Créer 3 points

                                            delegate: Rectangle {
                                                width: 12
                                                height: 12
                                                radius: 6 // Pour faire un cercle
                                                color: "gray"
                                                opacity: 0.5

                                                // Animation de pulsation
                                                SequentialAnimation on y {
                                                    loops: Animation.Infinite
                                                    // Attendre un peu avant de commencer (crée l'effet de vague)
                                                    PauseAnimation { duration: index * 150 }
                                                    // Monter
                                                    NumberAnimation { to: -5; duration: 300; easing.type: Easing.InOutQuad }
                                                    // Redescendre
                                                    NumberAnimation { to: 0; duration: 300; easing.type: Easing.InOutQuad }
                                                    // Pause en bas
                                                    PauseAnimation { duration: 400 }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        // Zone de saisie
                        Rectangle {
                            id: _inputMessageArea
                            Layout.fillWidth: true
                            height: 160
                            color: "white"
                            border.color: borderColor
                            border.width: 1

                            Item {
                                id: _filler
                                width: 10
                                height: 10
                                anchors { top: parent.top ; left: parent.left }
                            }
                            ScrollView {
                                id: scrollView
                                anchors { top: parent.top ; left: _filler.right }
                                height: 150
                                width: parent.width - 120
                                anchors { top: parent.top ; left: parent.left }

                                clip: true

                                ScrollBar.vertical.policy: ScrollBar.AsNeeded

                                TextArea {
                                    id: messageInput
                                    height: 150
                                    width: parent.width - 70
                                    wrapMode: Text.WordWrap
                                    placeholderText: "Saisissez votre message ici..."

                                    Keys.onPressed: (event) => {
                                        if ((event.key === Qt.Key_Return || event.key === Qt.Key_Enter) && (event.modifiers & Qt.ControlModifier)) {
                                            sendMessage();
                                            event.accepted = true;
                                        } else if (event.key === Qt.Key_PageUp) {
                                            _messageListView.contentY = Math.max(_messageListView.originY, _messageListView.contentY - _messageListView.height);
                                            event.accepted = true;
                                        } else if (event.key === Qt.Key_PageDown) {
                                            _messageListView.contentY = Math.min(_messageListView.contentHeight - _messageListView.height + _messageListView.originY, _messageListView.contentY + _messageListView.height);
                                            event.accepted = true;
                                        }
                                    }

                                    onContentHeightChanged: {
                                        scrollView.ScrollBar.vertical.position = 1.0;
                                    }

                                    Component.onCompleted: {
                                        forceActiveFocus()
                                    }
                                }

                            }

                            Button {
                                id: sendButton
                                width: 90
                                height: 80
                                anchors { verticalCenter: parent.verticalCenter ; right: verticalFiller.left }
                                text: "Send\n(Ctrl+Enter)"
                                background: Rectangle {
                                    color: sendButton.enabled ? sendButtonColor : "lightgray"
                                    radius: 6
                                }
                                contentItem: Text {
                                    text: sendButton.text
                                    color: "white"
                                    horizontalAlignment: Text.AlignHCenter
                                    verticalAlignment: Text.AlignVCenter
                                    font.bold: true
                                }

                                onClicked: sendMessage()
                                enabled: messageInput.text.trim().length > 0
                            }
                            Item {
                                id: verticalFiller
                                height: 1
                                width: 10
                                anchors { verticalCenter: parent.verticalCenter ; right: parent.right }
                            }
                        }

                        Frame {
                            id: fileManagementArea
                            Layout.fillWidth: true
                            Layout.preferredHeight: 150
                            Layout.topMargin: 5
                            visible: !_chatManager.chatModel || !_chatManager.chatModel.extendedContextEnabled

                            ColumnLayout {
                                anchors.fill: parent
                                anchors.margins: 5

                                Label {
                                    text: "Attached Files Library"
                                    font.bold: true
                                }

                                ScrollView {
                                    Layout.fillWidth: true
                                    Layout.fillHeight: true

                                    ListView {
                                        id: fileListView
                                        model: _chatManager.chatModel.managedFiles
                                        spacing: 5

                                        delegate: Rectangle {
                                            width: parent.width - 120
                                            height: 40
                                            color: "transparent"
                                            border.color: "#E0E0E0"
                                            border.width: 1
                                            radius: 4

                                            RowLayout {
                                                anchors.fill: parent
                                                anchors.margins: 5

                                                BusyIndicator {
                                                    running: model.status === 0 // ManagedFile.Uploading
                                                    visible: running
                                                    Layout.preferredHeight: 20
                                                    Layout.preferredWidth: 20
                                                }

                                                Label {
                                                    text: "✅"
                                                    visible: model.status === 1 // ManagedFile.Ready
                                                    font.pixelSize: 16
                                                    verticalAlignment: Text.AlignVCenter
                                                }

                                                Label {
                                                    text: model.fileName
                                                    elide: Text.ElideRight
                                                    Layout.fillWidth: true
                                                    verticalAlignment: Text.AlignVCenter
                                                }

                                                Button {
                                                    text: "✕"
                                                    flat: true
                                                    Layout.preferredWidth: 30
                                                    Layout.preferredHeight: 30
                                                    onClicked: {
                                                        _chatManager.chatModel.deleteUserFile(index)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }

                                Button {
                                    text: "Add File..."
                                    Layout.alignment: Qt.AlignRight
                                    onClicked: fileDialog.open()
                                }
                            }

                            // Le FileDialog est invisible, il ne s'ouvre que sur appel
                            FileDialog {
                                id: fileDialog
                                title: "Please choose a file to attach"
                                onAccepted: {
                                    _chatManager.chatModel.uploadUserFile(fileDialog.currentFile)
                                }
                            }
                        }
                    }
                }
            } // end _chatArea ColumnLayout

            // ── Image side-panel ──────────────────────────────────────────
            Rectangle {
                id: _imageSidePanel
                visible: _root.hasImages
                Layout.preferredWidth: 400
                Layout.fillHeight: true
                color: "#F0F0F0"
                border.color: "#E0E0E0"
                border.width: 1

                Column {
                    anchors {
                        top: parent.top
                        horizontalCenter: parent.horizontalCenter
                        topMargin: 12
                    }
                    spacing: 12

                    // Image 1
                    Image {
                        id: _charImage1
                        source: _chatManager.activeInterlocutorImagePath1 !== ""
                                ? ("file:///" + _chatManager.activeInterlocutorImagePath1.replace(/\\/g, "/"))
                                : ""
                        visible: _chatManager.activeInterlocutorImagePath1 !== ""
                        width: 376
                        height: 376
                        fillMode: Image.PreserveAspectFit
                        smooth: true
                        cache: false

                        Rectangle {
                            anchors.fill: parent
                            color: "transparent"
                            border.color: "#BDBDBD"
                            border.width: 1
                            radius: 4
                        }
                    }

                    // Image 2
                    Image {
                        id: _charImage2
                        source: _chatManager.activeInterlocutorImagePath2 !== ""
                                ? ("file:///" + _chatManager.activeInterlocutorImagePath2.replace(/\\/g, "/"))
                                : ""
                        visible: _chatManager.activeInterlocutorImagePath2 !== ""
                        width: 376
                        height: 376
                        fillMode: Image.PreserveAspectFit
                        smooth: true
                        cache: false

                        Rectangle {
                            anchors.fill: parent
                            color: "transparent"
                            border.color: "#BDBDBD"
                            border.width: 1
                            radius: 4
                        }
                    }
                } // Column
            } // _imageSidePanel

            } // end _chatAreaRow RowLayout

            // 1.2.2 `_configArea` : Configuration form: IP address of the API endpoint, API Key,
            // Size of the rolling context, directories used for data storage, ...
            // ------------------------------
            // 1.2.2 `_configArea` : Fenêtre de Configuration
            RowLayout {
                id: _configArea
                Layout.fillWidth: true
                Layout.fillHeight: true
                spacing: 10
                visible: _tabBar.currentIndex === 1 // S'assurer que la visibilité est bien gérée
                // Fonction QML pour synchroniser les ComboBoxs de Provider et Model
                function syncProviderModel() {
                    if (!_chatManager.currentConfig) return;

                    // 1. Synchroniser le Provider ComboBox
                    let providerIndex = providerComboBox.model.indexOf(_chatManager.currentConfig.type);
                    providerComboBox.currentIndex = providerIndex;

                    // 2. Charger le modèle des modèles pour ce provider
                    let providerName = providerIndex >= 0 ? providerComboBox.model[providerIndex] : "";
                    modelComboBox.model = _chatManager.modelsForProvider(providerName);

                    // 3. Synchroniser le Model ComboBox
                    let modelIndex = modelComboBox.model.indexOf(_chatManager.currentConfig.modelName);
                    modelComboBox.currentIndex = modelIndex;

                    // CORRECTION: Si le fournisseur est chargé sans modèle (nouvelle config), on choisit le premier
                    if (modelIndex < 0 && modelComboBox.model && modelComboBox.model.length > 0 && !_chatManager.currentConfig.modelName) {
                        modelComboBox.currentIndex = 0;
                        // On déclenche l'action associée pour mettre à jour l'URL et le nom dans la config
                        modelComboBox.onActivated(0);
                    }
                }

                // --- Panneau de gauche : Liste des interlocuteurs ---
                Frame {
                    Layout.preferredWidth: 200
                    Layout.fillHeight: true

                    ColumnLayout {
                        anchors.fill: parent

                        Label {
                            text: "Interlocutors"
                            font.bold: true
                            Layout.alignment: Qt.AlignHCenter
                        }

                        ListView {
                            id: configListView
                            Layout.fillWidth: true
                            Layout.fillHeight: true
                            model: _chatManager? _chatManager.interlocutorNames : ""
                            currentIndex: -1

                            delegate: ItemDelegate {
                                text: modelData
                                width: parent.width
                                highlighted: ListView.isCurrentItem
                                onClicked: {
                                    configListView.currentIndex = index;
                                    _chatManager.selectConfigToEdit(modelData);
                                }
                            }
                        }
                        Button {
                            text: "Add New Interlocutor"
                            Layout.fillWidth: true
                            onClicked: {
                                configListView.currentIndex = -1; // Désélectionner
                                _chatManager.createNewConfig();
                            }
                        }
                    }
                }

                // --- Panneau de droite : Formulaire de configuration ---
                Frame {
                    Layout.fillWidth: true
                    Layout.fillHeight: true

                    // On affiche le formulaire seulement si un item est sélectionné ou en cours de création
                    enabled: _chatManager.currentConfig !== null
                    // Ce bloc écoute le changement de l'objet de configuration C++
                    Connections {
                        target: _chatManager
                        // Ce signal est émis chaque fois qu'on sélectionne un interlocuteur existant
                        // ou qu'on en crée un nouveau.
                        function onCurrentConfigChanged() {
                            if (!_chatManager.currentConfig) return;

                            // 1. Provider
                            providerComboBox.currentIndex = providerComboBox.model.indexOf(_chatManager.currentConfig.type);

                            // 2. Models (on met à jour le modèle AVANT de chercher l'index)
                            var provider = _chatManager.currentConfig.type;
                            if (provider) {
                                modelComboBox.model = _chatManager.modelsForProvider(provider);
                                // MAINTENANT on peut chercher l'index dans le BON modèle
                                modelComboBox.currentIndex = modelComboBox.model.indexOf(_chatManager.currentConfig.modelName);
                            } else {
                                modelComboBox.model = [];
                                modelComboBox.currentIndex = -1;
                            }

                            // 3. Rafraîchir les miniatures image dans la config
                            _configImg1Preview.imgPath = _chatManager.getInterlocutorImagePath(_chatManager.currentConfig.name, 1)
                            _configImg2Preview.imgPath = _chatManager.getInterlocutorImagePath(_chatManager.currentConfig.name, 2)
                        }
                    }

                    ScrollView {
                        anchors.fill: parent

                        GridLayout {
                            width: parent.width
                            columns: 2

                            Item {
                                id: filler1
                                width: 10
                                height: 10
                            }
                            Item {
                                id: filler2
                                width: 10
                                height: 10
                            }

                            // Le nom (ne peut pas être édité pour un existant pour l'instant)
                            Label { text: qsTr("Name:") }
                            TextField {
                                id: nameField
                                Layout.fillWidth: true
                                text: _chatManager.currentConfig ? _chatManager.currentConfig.name : ""
                                placeholderText: "Unique name (e.g., 'Work Assistant')"
                                // Synchroniser la valeur vers le C++
                                onTextChanged: if (_chatManager.currentConfig) _chatManager.currentConfig.name = text
                            }

                            Label { text: qsTr("Provider:") }
                            ComboBox {
                                id: providerComboBox
                                Layout.fillWidth: true
                                model: _chatManager.availableProviders

                                // Mettre à jour config.type et charge le modèle de la ComboBox suivante.
                                onActivated: (index) => {
                                                 if (!_chatManager.currentConfig) return;

                                                 // 1. Mise à jour du type dans la config C++
                                                 _chatManager.currentConfig.type = model[index];

                                                 // 2. Mise à jour du modèle de la ComboBox des modèles
                                                 modelComboBox.model = _chatManager.modelsForProvider(model[index]);

                                                 // 3. Sélectionner le premier modèle par défaut
                                                 if (modelComboBox.model.length > 0) {
                                                     modelComboBox.currentIndex = 0;
                                                     // Déclencher l'action pour que le C++ mette à jour le nom du modèle et l'URL
                                                     modelComboBox.onActivated(0);
                                                 }
                                             }

                            }

                            // Nouvelle ComboBox pour le Modèle
                            Label { text: qsTr("Model:") }
                            ComboBox {
                                id: modelComboBox
                                Layout.fillWidth: true
                                onActivated: (index) => {
                                                 if (!_chatManager.currentConfig) return;
                                                 // Synchronisation vers le C++ (met à jour modelName et endpointUrl)
                                                 _chatManager.updateConfigWithModel(model[index]);
                                             }
                            }

                            // Clé API
                            Label { text: "API Key:" }
                            TextField {
                                id: apiKeyField
                                Layout.fillWidth: true
                                text: _chatManager.currentConfig ? _chatManager.currentConfig.apiKey : ""
                                placeholderText: "sk-..."
                                echoMode: TextInput.Password
                                onTextChanged: if (_chatManager.currentConfig) _chatManager.currentConfig.apiKey = text
                            }

                            // Endpoint URL
                            Label { text: "Endpoint URL:" }
                            TextField {
                                id: endpointUrlField
                                Layout.fillWidth: true
                                text: _chatManager.currentConfig ? _chatManager.currentConfig.endpointUrl : ""
                                readOnly: true // L'utilisateur n'a plus à s'en soucier !
                                placeholderText: "Auto-filled based on model selection"
                            }

                            // Instructions Personnalisées (System Prompt)
                            Label {
                                text: "Custom Instructions:"
                                Layout.alignment: Qt.AlignTop
                            }
                            ScrollView {
                                Layout.fillWidth: true
                                Layout.preferredHeight: 200
                                clip: true
                                ScrollBar.vertical.policy: ScrollBar.AlwaysOn

                                TextArea {
                                    id: systemPromptArea
                                    width: parent.width // Important pour le wrapMode
                                    text: _chatManager && _chatManager.currentConfig ? _chatManager.currentConfig.systemPrompt : ""
                                    placeholderText: "You are a helpful assistant..."
                                    wrapMode: Text.Wrap
                                    onTextChanged: if (_chatManager.currentConfig) _chatManager.currentConfig.systemPrompt = text
                                }
                            }

                            // ── Images de personnage ──────────────────────────────────────
                            Label {
                                text: qsTr("Character Image 1:")
                                Layout.alignment: Qt.AlignTop
                            }
                            RowLayout {
                                spacing: 8
                                // Miniature de l'image 1
                                Image {
                                    id: _configImg1Preview
                                    property string imgPath: _chatManager.currentConfig
                                        ? _chatManager.getInterlocutorImagePath(_chatManager.currentConfig.name, 1)
                                        : ""
                                    source: imgPath !== "" ? ("file:///" + imgPath.replace(/\\/g, "/")) : ""
                                    visible: imgPath !== ""
                                    width: 60; height: 60
                                    fillMode: Image.PreserveAspectFit
                                    smooth: true
                                    cache: false
                                }
                                // Bouton upload / effacement image 1
                                Button {
                                    text: _configImg1Preview.imgPath !== "" ? qsTr("✕ Clear") : qsTr("Upload…")
                                    onClicked: {
                                        if (_configImg1Preview.imgPath !== "") {
                                            _chatManager.clearInterlocutorImage(_chatManager.currentConfig.name, 1)
                                            _configImg1Preview.imgPath = ""
                                        } else {
                                            imgDialog1.open()
                                        }
                                    }
                                }
                                FileDialog {
                                    id: imgDialog1
                                    title: qsTr("Choisissez l'image 1 du personnage")
                                    nameFilters: [ "Images (*.jpg *.jpeg *.png)" ]
                                    onAccepted: {
                                        if (_chatManager.setInterlocutorImage(_chatManager.currentConfig.name, 1, imgDialog1.currentFile)) {
                                            _configImg1Preview.imgPath =
                                                _chatManager.getInterlocutorImagePath(_chatManager.currentConfig.name, 1)
                                        }
                                    }
                                }
                            }

                            Label {
                                text: qsTr("Character Image 2:")
                                Layout.alignment: Qt.AlignTop
                            }
                            RowLayout {
                                spacing: 8
                                // Miniature de l'image 2
                                Image {
                                    id: _configImg2Preview
                                    property string imgPath: _chatManager.currentConfig
                                        ? _chatManager.getInterlocutorImagePath(_chatManager.currentConfig.name, 2)
                                        : ""
                                    source: imgPath !== "" ? ("file:///" + imgPath.replace(/\\/g, "/")) : ""
                                    visible: imgPath !== ""
                                    width: 60; height: 60
                                    fillMode: Image.PreserveAspectFit
                                    smooth: true
                                    cache: false
                                }
                                // Bouton upload / effacement image 2
                                Button {
                                    text: _configImg2Preview.imgPath !== "" ? qsTr("✕ Clear") : qsTr("Upload…")
                                    onClicked: {
                                        if (_configImg2Preview.imgPath !== "") {
                                            _chatManager.clearInterlocutorImage(_chatManager.currentConfig.name, 2)
                                            _configImg2Preview.imgPath = ""
                                        } else {
                                            imgDialog2.open()
                                        }
                                    }
                                }
                                FileDialog {
                                    id: imgDialog2
                                    title: qsTr("Choisissez l'image 2 du personnage")
                                    nameFilters: [ "Images (*.jpg *.jpeg *.png)" ]
                                    onAccepted: {
                                        if (_chatManager.setInterlocutorImage(_chatManager.currentConfig.name, 2, imgDialog2.currentFile)) {
                                            _configImg2Preview.imgPath =
                                                _chatManager.getInterlocutorImagePath(_chatManager.currentConfig.name, 2)
                                        }
                                    }
                                }
                            }

                            // Espace vide pour pousser les boutons en bas
                            Item { Layout.fillHeight: true; Layout.columnSpan: 2 }

                            // Boutons d'action
                            Item {} // Cellule vide
                            RowLayout {
                                Layout.alignment: Qt.AlignRight
                                Button {
                                    text: qsTr("Save Changes")
                                    highlighted: true
                                    onClicked: {
                                        if (_chatManager.saveConfig(_chatManager.currentConfig)) {
                                            // Succès ! On pourrait afficher une notification.
                                            configListView.currentIndex = configListView.model.indexOf(nameField.text)
                                        } else {
                                            // Échec, afficher une erreur.
                                        }
                                    }
                                }
                                Button {
                                    text: "Delete"
                                    // ... logique de suppression avec confirmation ...
                                    // !!! DANGEREUX !!!
                                    // POUR L'INSTANT CA NE FAIT RIEN...
                                    // MAIS DEMANDER DEUX OU TROIS CONFIRMATION CLAIRE AVANT D'EFFACER QUOIQUE CE SOIT !!!
                                }
                                Button {
                                    text: "Reset Session Cost"
                                    onClicked: _chatManager.chatModel.resetTokenCost()
                                }
                            }
                        }
                    }
                }
            }
            // 1.2.3 `_infoArea` : Information page, versions, details, URL of the github, ...
            // ------------------------------
            ColumnLayout {
                id: _infoArea
                visible: true
                width: parent.width
                Layout.fillHeight: true
                Label {
                    text: "Information Window : PLACEHOLDER, TO BE IMPLEMENTED"
                }
            }
        }
    }
}
// End Source File Main.qml
