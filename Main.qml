// Begin source file Main.qml
import QtQuick
import QtQuick.Controls
import QtQuick.Layouts

import Tether 1.0

ApplicationWindow {
    id: _root
    visible: true
    width: 960
    height: 800

    // Custom colors
    property color humanMessageColor: "#fff8e1"  // pale yellow
    property color aiMessageColor: "#e3f2fd"     // pale blue
    property color borderColor: "#E0E0E0"
    property color sendButtonColor: "#2196F3"

    property var currentChatModel: _chatManager.chatModel

    // Fonction pour envoyer le message
    function sendMessage() {
        var text = messageInput.text.trim();
        if (text.length > 0) {
            currentChatModel.sendMessage(text);
            messageInput.text = "";
        }
    }
    //// Connecter aux signaux de chatModel pour la gestion des erreurs et le défilement
    //Connections {
    //    target: currentChatModel
    //    function onChatMessageAdded(message) {
    //        _messageListView.positionViewAtEnd();
    //    }
    //    function onChatError(error) {
    //        console.error("Chat Error:", error);
    //        // Afficher l'erreur à l'utilisateur, par exemple dans une petite bulle ou une toast
    //    }
    //    function onTotalTokensChanged() {
    //        console.log("Total tokens:", chatModel.totalTokens);
    //        // TODO: Mettre à jour un QLabel pour afficher le nombre de tokens
    //    }
    //}


    // 1._headerChatareaDivide: separates vertically the main window in two parts: the banner
    // containing the Tab bar on top, and the main area in the rest of the window. The nature
    // of the main area is defined by the active tab: either chat area, or configuration form,
    // or "about/help/licence informations"
    ColumnLayout {
        id: _headerChatareaDivide
        anchors.fill: parent
        width: parent.width
        height: parent.height
        // 1.1 `_menuBar` : Manages the TAB bar and other buttons for the application controls
        // (common to all pages).
        RowLayout {
            id: _menuBar
            implicitHeight: 40
            width: parent.width
            TabBar {
                id: _tabBar
                currentIndex: 0

                TabButton {
                    font.bold: checked
                    text: qsTr("Chat")
                    width: implicitWidth
                }
                TabButton {
                    font.bold: checked
                    text: qsTr("Configure")
                    width: implicitWidth
                }
                TabButton {
                    font.bold: checked
                    text: qsTr("About")
                    width: implicitWidth
                }
            }
            Item {
                Layout.fillWidth: true
            }
            Label {
                text: "Session cost: " + _chatManager.chatModel ? (_chatManager.chatModel.cumulativeTokenCost + " tokens"): ""
            }
            Button {
                id: _displayLicence
                visible: _tabBar.currentIndex === 2
                text: qsTr("Display Licence")
                height: 40
                width:80
                onClicked: {
                    // _debugLogs.open() // Si vous voulez toujours l'utiliser pour la licence
                }
            }
            ComboBox {
                id: languageSelector
                width: 240
                height: 40
                model: [ "English", "Français"]
                displayText: _settings?model[_settings.language]:"#####"
                currentIndex : 0
                onCurrentIndexChanged: {
                    if (_settings.changingLanguage) {
                        // We're currently loading the new current language.
                        // This is a false event generated by engine.retranslate(),
                        // we must ignore it
                        return;
                    }
                    _settings.language = currentIndex ;
                }
            }
            ComboBox {
                id: interlocutorSelector
                model: _chatManager.interlocutorNames // Le ComboBox se remplit automatiquement
                currentIndex: model.indexOf(_chatManager.activeInterlocutorName) // Sélectionne l'actif

                onActivated: (index) => {
                                 // Quand l'utilisateur choisit, on appelle le manager
                                 _chatManager.switchToInterlocutor(interlocutorSelector.model[index])
                             }
            }
            Item {
                width:40
            }
        }

        // 1.2 `_mainArea` : manages the different version of the main area (chat, configuration, about, ...)
        StackLayout {
            id: _mainArea
            currentIndex: _tabBar.currentIndex
            Layout.fillWidth: true
            Layout.fillHeight: true
            Layout.alignment: Qt.AlignHCenter

            // 1.2.1 `_chatArea` : Chat Window content, composed of:
            // - a ListView of the former messages from the current dialog
            // - the input area where the human can type their message.
            ColumnLayout {
                id: _chatArea
                width: parent.width
                Layout.fillHeight: true
                Layout.fillWidth: true


                Rectangle {
                    id: _messagesArea
                    Layout.fillWidth: true
                    Layout.fillHeight: true
                    color: "#FAFAFA"
                    ColumnLayout {
                        id: _messageColumn
                        anchors.fill: parent
                        spacing: 0

                        // Zone des messages (ListView)
                        ListView {
                            id: _messageListView
                            Layout.fillWidth: true
                            Layout.fillHeight: true
                            Layout.margins: 10
                            spacing: 15
                            clip: true
                            verticalLayoutDirection: ListView.TopToBottom
                            model: _chatManager.chatModel
                            Component.onCompleted: {
                                // On demande à la vue de se positionner à la fin de son contenu.
                                positionViewAtEnd()
                            }
                            delegate: Item {
                                id: _singleMessageArea
                                // _singleMessageArea : is the invisible rectangle occupying the full
                                // width of the window and as high as the message. Inside this
                                // invisible placeholder we'll display the message bubble, aka the rounded
                                // rectangle on 80% of the width aligned left or right with the text in it.
                                Layout.preferredWidth: _messageListView.width
                                Layout.preferredHeight: _messageBubble.height
                                implicitHeight: _messageBubble.height
                                implicitWidth: _messageListView.width
                                Rectangle {
                                    id: _messageBubble
                                    // _messageBubble: the visible rectangle with rounded corners with
                                    // the message inside.
                                    width: Math.min(_messageText.implicitWidth + 20, parent.width * 0.8)
                                    height: _messageText.implicitHeight + 20
                                    radius: 12
                                    border.width: 1
                                    border.color: borderColor
                                    color: model.isLocalMessage ? humanMessageColor : aiMessageColor
                                    anchors.top: parent.top
                                    anchors.left: model.isLocalMessage ? parent.left : undefined // Ancre à gauche si humain
                                    anchors.right: model.isLocalMessage ? undefined : parent.right // Ancre à droite si IA

                                    Text {
                                        id: _messageText
                                        anchors.fill: parent
                                        anchors.margins: 10
                                        text: model.text
                                        wrapMode: Text.Wrap
                                        font.pixelSize: 14
                                        color: "#333333"
                                        // Définir une largeur maximale pour que implicitHeight soit calculé correctement
                                        width: parent.width - 20 // 20 pour les marges du parent (messageBubble)
                                    }

                                }
                            }
                            // When the `Interlocutor` model will be implemented as a `QAbstractListModel`,
                            // we must connect the signals/slots so the QML reflects the new reply
                            Connections {
                                target: _chatManager.chatModel
                                function onChatMessageAdded() {
                                    _messageListView.positionViewAtEnd()
                                }
                            }
                        }
                        // Zone de saisie
                        Rectangle {
                            id: _inputMessageArea
                            Layout.fillWidth: true
                            height: 160
                            color: "white"
                            border.color: borderColor
                            border.width: 1

                            Item {
                                id: _filler
                                width: 10
                                height: 10
                                anchors { top: parent.top ; left: parent.left }
                            }
                            ScrollView {
                                id: scrollView
                                anchors { top: parent.top ; left: _filler.right }
                                height: 150
                                width: parent.width - 70
                                anchors { top: parent.top ; left: parent.left }

                                //Layout.fillHeight: true
                                clip: true

                                ScrollBar.vertical.policy: ScrollBar.AsNeeded

                                TextArea {
                                    id: messageInput
                                    height: 150
                                    width: parent.width - 70
                                    wrapMode: Text.WordWrap
                                    placeholderText: "Saisissez votre message ici..."

                                    onContentHeightChanged: {
                                        scrollView.ScrollBar.vertical.position = 1.0;
                                    }

                                    Component.onCompleted: {
                                        forceActiveFocus()
                                    }
                                }

                            }

                            Button {
                                id: sendButton
                                width: 60
                                height: 30
                                anchors { verticalCenter: parent.verticalCenter ; right: parent.right }
                                text: "Envoi"
                                background: Rectangle {
                                    color: sendButton.enabled ? sendButtonColor : "lightgray"
                                    radius: 6
                                }
                                contentItem: Text {
                                    text: sendButton.text
                                    color: "white"
                                    horizontalAlignment: Text.AlignHCenter
                                    verticalAlignment: Text.AlignVCenter
                                    font.bold: true
                                }

                                onClicked: sendMessage()
                                enabled: messageInput.text.trim().length > 0
                            }
                        }
                    }
                }
            }
            // 1.2.2 `_configArea` : Configuration form: IP address of the API endpoint, API Key,
            // Size of the rolling context, directories used for data storage, ...
            // ------------------------------
            // 1.2.2 `_configArea` : Fenêtre de Configuration
            RowLayout {
                id: _configArea
                Layout.fillWidth: true
                Layout.fillHeight: true
                spacing: 10
                visible: _tabBar.currentIndex === 1 // S'assurer que la visibilité est bien gérée
                // Fonction QML pour synchroniser les ComboBoxs de Provider et Model
                function syncProviderModel() {
                    if (!_chatManager.currentConfig) return;

                    // 1. Synchroniser le Provider ComboBox
                    let providerIndex = providerComboBox.model.indexOf(_chatManager.currentConfig.type);
                    providerComboBox.currentIndex = providerIndex;

                    // 2. Charger le modèle des modèles pour ce provider
                    let providerName = providerIndex >= 0 ? providerComboBox.model[providerIndex] : "";
                    modelComboBox.model = _chatManager.modelsForProvider(providerName);

                    // 3. Synchroniser le Model ComboBox
                    let modelIndex = modelComboBox.model.indexOf(_chatManager.currentConfig.modelName);
                    modelComboBox.currentIndex = modelIndex;

                    // CORRECTION: Si le fournisseur est chargé sans modèle (nouvelle config), on choisit le premier
                    if (modelIndex < 0 && modelComboBox.model && modelComboBox.model.length > 0 && !_chatManager.currentConfig.modelName) {
                        modelComboBox.currentIndex = 0;
                        // On déclenche l'action associée pour mettre à jour l'URL et le nom dans la config
                        modelComboBox.onActivated(0);
                    }
                }

                // --- Panneau de gauche : Liste des interlocuteurs ---
                Frame {
                    Layout.preferredWidth: 200
                    Layout.fillHeight: true

                    ColumnLayout {
                        anchors.fill: parent

                        Label {
                            text: "Interlocutors"
                            font.bold: true
                            Layout.alignment: Qt.AlignHCenter
                        }

                        ListView {
                            id: configListView
                            Layout.fillWidth: true
                            Layout.fillHeight: true
                            model: _chatManager.interlocutorNames
                            currentIndex: -1

                            delegate: ItemDelegate {
                                text: modelData
                                width: parent.width
                                highlighted: ListView.isCurrentItem
                                onClicked: {
                                    configListView.currentIndex = index;
                                    _chatManager.selectConfigToEdit(modelData);
                                }
                            }
                        }
                        Button {
                            text: "Add New Interlocutor"
                            Layout.fillWidth: true
                            onClicked: {
                                configListView.currentIndex = -1; // Désélectionner
                                _chatManager.createNewConfig();
                            }
                        }
                    }
                }

                // --- Panneau de droite : Formulaire de configuration ---
                Frame {
                    Layout.fillWidth: true
                    Layout.fillHeight: true

                    // On affiche le formulaire seulement si un item est sélectionné ou en cours de création
                    enabled: _chatManager.currentConfig !== null
                    // *** POINT CRUCIAL DE SYNCHRONISATION ***
                    // Ce bloc écoute le changement de l'objet de configuration C++
                    Connections {
                        target: _chatManager
                        function onCurrentConfigChanged() {
                            // Dès que l'objet C++ change (sélection ou nouvelle création), on synchronise l'UI
                            syncProviderModel();
                        }
                    }

                    ScrollView {
                        anchors.fill: parent

                        GridLayout {
                            width: parent.width
                            columns: 2

                            Item {
                                id: filler1
                                width: 10
                                height: 10
                            }
                            Item {
                                id: filler2
                                width: 10
                                height: 10
                            }

                            // Le nom (ne peut pas être édité pour un existant pour l'instant)
                            Label { text: qsTr("Name:") }
                            TextField {
                                id: nameField
                                Layout.fillWidth: true
                                text: _chatManager.currentConfig ? _chatManager.currentConfig.name : ""
                                placeholderText: "Unique name (e.g., 'Work Assistant')"
                                // Synchroniser la valeur vers le C++
                                onTextChanged: if (_chatManager.currentConfig) _chatManager.currentConfig.name = text
                            }

                            Label { text: qsTr("Provider:") }
                            ComboBox {
                                id: providerComboBox
                                Layout.fillWidth: true
                                model: _chatManager.availableProviders

                                // Mettre à jour config.type et charge le modèle de la ComboBox suivante.
                                onActivated: (index) => {
                                                 if (!_chatManager.currentConfig) return;

                                                 // 1. Mise à jour du type dans la config C++
                                                 _chatManager.currentConfig.type = model[index];

                                                 // 2. Mise à jour du modèle de la ComboBox des modèles
                                                 modelComboBox.model = _chatManager.modelsForProvider(model[index]);

                                                 // 3. Sélectionner le premier modèle par défaut
                                                 if (modelComboBox.model.length > 0) {
                                                     modelComboBox.currentIndex = 0;
                                                     // Déclencher l'action pour que le C++ mette à jour le nom du modèle et l'URL
                                                     modelComboBox.onActivated(0);
                                                 }
                                             }

                            }

                            // Nouvelle ComboBox pour le Modèle
                            Label { text: qsTr("Model:") }
                            ComboBox {
                                id: modelComboBox
                                Layout.fillWidth: true
                                onActivated: (index) => {
                                       if (!_chatManager.currentConfig) return;
                                       // Synchronisation vers le C++ (met à jour modelName et endpointUrl)
                                       _chatManager.updateConfigWithModel(model[index]);
                                   }
                            }

                            // Clé API
                            Label { text: "API Key:" }
                            TextField {
                                id: apiKeyField
                                Layout.fillWidth: true
                                text: _chatManager.currentConfig ? _chatManager.currentConfig.apiKey : ""
                                placeholderText: "sk-..."
                                echoMode: TextInput.Password
                                onTextChanged: if (_chatManager.currentConfig) _chatManager.currentConfig.apiKey = text
                            }

                            // Endpoint URL
                            Label { text: "Endpoint URL:" }
                            TextField {
                                id: endpointUrlField
                                Layout.fillWidth: true
                                text: _chatManager.currentConfig ? _chatManager.currentConfig.endpointUrl : ""
                                readOnly: true // L'utilisateur n'a plus à s'en soucier !
                                placeholderText: "Auto-filled based on model selection"
                            }

                            // Instructions Personnalisées (System Prompt)
                            Label {
                                text: "Custom Instructions:"
                                Layout.alignment: Qt.AlignTop
                            }
                            TextArea {
                                id: systemPromptArea
                                Layout.fillWidth: true
                                Layout.preferredHeight: 200
                                text: _chatManager.currentConfig ? _chatManager.currentConfig.systemPrompt : ""
                                placeholderText: "You are a helpful assistant..."
                                wrapMode: Text.Wrap
                                onTextChanged: if (_chatManager.currentConfig) _chatManager.currentConfig.systemPrompt = text
                            }

                            // Espace vide pour pousser les boutons en bas
                            Item { Layout.fillHeight: true; Layout.columnSpan: 2 }

                            // Boutons d'action
                            Item {} // Cellule vide
                            RowLayout {
                                Layout.alignment: Qt.AlignRight
                                Button {
                                    text: qsTr("Save Changes")
                                    highlighted: true
                                    onClicked: {
                                        if (_chatManager.saveConfig(_chatManager.currentConfig)) {
                                            // Succès ! On pourrait afficher une notification.
                                            configListView.currentIndex = configListView.model.indexOf(nameField.text)
                                        } else {
                                            // Échec, afficher une erreur.
                                        }
                                    }
                                }
                                Button {
                                    text: "Delete"
                                    // ... logique de suppression avec confirmation ...
                                    // !!! DANGEREUX !!!
                                    // POUR L'INSTANT CA NE FAIT RIEN...
                                    // MAIS DEMANDER DEUX OU TROIS CONFIRMATION CLAIRE AVANT D'EFFACER QUOIQUE CE SOIT !!!
                                }
                                Button {
                                    text: "Reset Session Cost"
                                    onClicked: _chatManager.chatModel.resetTokenCost()
                                }
                            }
                        }
                    }
                }
            }
            // 1.2.3 `_infoArea` : Information page, versions, details, URL of the github, ...
            // ------------------------------
            ColumnLayout {
                id: _infoArea
                visible: true
                width: parent.width
                Layout.fillHeight: true
                Label {
                    text: "Information Window : PLACEHOLDER, TO BE IMPLEMENTED"
                }
            }
        }
    }
}
// End Source File Main.qml
