// Begin source file Main.qml
import QtQuick
import QtQuick.Controls
import QtQuick.Layouts
import QtQuick.Dialogs
import Tether 1.0

ApplicationWindow {
    id: _root
    visible: true
    width: 960
    height: 800

    // Custom colors
    property color humanMessageColor: "#fff8e1"  // pale yellow
    property color aiMessageColor: "#e3f2fd"     // pale blue
    property color borderColor: "#E0E0E0"
    property color sendButtonColor: "#2196F3"

    property var currentChatModel: _chatManager.chatModel

    // Fonction pour envoyer le message
    function sendMessage() {
        var text = messageInput.text.trim();
        if (text.length > 0) {
            currentChatModel.sendMessage(text);
            messageInput.text = "";
        }
    }

    Connections {
        target: chatModel
        function onChatError(message) {
            console.warn("Chat error:", message)
            // Afficher ici une popup ou quelque chose.
            errorBanner.text = message
            errorBanner.visible = true
        }
    }

    // 1._headerChatareaDivide: separates vertically the main window in two parts: the banner
    // containing the Tab bar on top, and the main area in the rest of the window. The nature
    // of the main area is defined by the active tab: either chat area, or configuration form,
    // or "about/help/licence informations"
    ColumnLayout {
        id: _headerChatareaDivide
        anchors.fill: parent
        width: parent.width
        height: parent.height
        // 1.1 `_menuBar` : Manages the TAB bar and other buttons for the application controls
        // (common to all pages).
        RowLayout {
            id: _menuBar
            implicitHeight: 40
            width: parent.width
            TabBar {
                id: _tabBar
                currentIndex: 0

                TabButton {
                    font.bold: checked
                    text: qsTr("Chat")
                    width: implicitWidth
                }
                TabButton {
                    font.bold: checked
                    text: qsTr("Configure")
                    width: implicitWidth
                }
                TabButton {
                    font.bold: checked
                    text: qsTr("About")
                    width: implicitWidth
                }
            }
            Item {
                Layout.fillWidth: true
            }
            Label {
                text: "Session cost: " + _chatManager.chatModel ? (_chatManager.chatModel.cumulativeTokenCost + " tokens"): ""
            }
            Button {
                id: _displayLicence
                visible: _tabBar.currentIndex === 2
                text: qsTr("Display Licence")
                height: 40
                width:80
                onClicked: {
                    // _debugLogs.open() // Si vous voulez toujours l'utiliser pour la licence
                }
            }
            ComboBox {
                id: languageSelector
                width: 240
                height: 40
                model: [ "English", "Français"]
                displayText: _settings?model[_settings.language]:"#####"
                currentIndex : 0
                onCurrentIndexChanged: {
                    if (_settings.changingLanguage) {
                        // We're currently loading the new current language.
                        // This is a false event generated by engine.retranslate(),
                        // we must ignore it
                        return;
                    }
                    _settings.language = currentIndex ;
                }
            }
            ComboBox {
                id: interlocutorSelector
                model: _chatManager.interlocutorNames // Le ComboBox se remplit automatiquement
                currentIndex: model.indexOf(_chatManager.activeInterlocutorName) // Sélectionne l'actif

                onActivated: (index) => {
                                 // Quand l'utilisateur choisit, on appelle le manager
                                 _chatManager.switchToInterlocutor(interlocutorSelector.model[index])
                             }
            }
            Item {
                width:40
            }
        }

        // 1.2 `_mainArea` : manages the different version of the main area (chat, configuration, about, ...)
        StackLayout {
            id: _mainArea
            currentIndex: _tabBar.currentIndex
            Layout.fillWidth: true
            Layout.fillHeight: true
            Layout.alignment: Qt.AlignHCenter

            // 1.2.1 `_chatArea` : Chat Window content, composed of:
            // - a ListView of the former messages from the current dialog
            // - the input area where the human can type their message.
            ColumnLayout {
                id: _chatArea
                width: parent.width
                Layout.fillHeight: true
                Layout.fillWidth: true


                Rectangle {
                    id: _messagesArea
                    Layout.fillWidth: true
                    Layout.fillHeight: true
                    color: "#FAFAFA"
                    ColumnLayout {
                        id: _messageColumn
                        anchors.fill: parent
                        spacing: 0

                        // Zone des messages (ListView)
                        ListView {
                            id: _messageListView
                            Layout.fillWidth: true
                            Layout.fillHeight: true
                            Layout.margins: 10
                            spacing: 15
                            clip: true
                            verticalLayoutDirection: ListView.TopToBottom
                            model: _chatManager.chatModel
                            Component.onCompleted: {
                                // On demande à la vue de se positionner à la fin de son contenu.
                                positionViewAtEnd()
                            }
                            Connections {
                                target: _chatManager.chatModel
                                function onModelReset() { Qt.callLater(_messageListView.positionViewAtEnd); }
                                function onChatMessageAdded() { _messageListView.positionViewAtEnd(); }
                            }
                            ScrollBar.vertical: ScrollBar {
                                policy: ScrollBar.AsNeeded
                            }

                            delegate: Item {
                                id: _singleMessageArea
                                // _singleMessageArea : is the invisible rectangle occupying the full
                                // width of the window and as high as the message. Inside this
                                // invisible placeholder we'll display the message bubble, aka the rounded
                                // rectangle on 80% of the width aligned left or right with the text in it.
                                Layout.preferredWidth: _messageListView.width
                                Layout.preferredHeight: _messageBubble.height
                                implicitHeight: _messageBubble.height
                                implicitWidth: _messageListView.width
                                Rectangle {
                                    id: _messageBubble
                                    // _messageBubble: the visible rectangle with rounded corners with
                                    // the message inside.
                                    visible: !model.isTypingIndicator
                                    width: Math.min(_messageText.implicitWidth + 20, parent.width * 0.8)
                                    height: _messageText.implicitHeight + 20
                                    radius: 12
                                    border.width: 1
                                    border.color: borderColor
                                    color: model.isLocalMessage ? humanMessageColor : aiMessageColor
                                    anchors.top: parent.top
                                    anchors.left: model.isLocalMessage ? parent.left : undefined // Ancre à gauche si humain
                                    anchors.right: model.isLocalMessage ? undefined : parent.right // Ancre à droite si IA

                                    Text {
                                        id: _messageText
                                        anchors.fill: parent
                                        anchors.margins: 10
                                        text: model.text
                                        wrapMode: Text.Wrap
                                        font.pixelSize: 14
                                        color: "#333333"
                                        // Définir une largeur maximale pour que implicitHeight soit calculé correctement
                                        width: parent.width - 20 // 20 pour les marges du parent (messageBubble)
                                    }

                                }
                                Item {
                                    id: typingIndicator
                                    visible: model.isTypingIndicator
                                    width: 80
                                    height: 40
                                    // Ancré à gauche comme un message de l'IA
                                    anchors.left: parent.left
                                    anchors.leftMargin: 10

                                    RowLayout {
                                        anchors.verticalCenter: parent.verticalCenter
                                        spacing: 5

                                        Repeater {
                                            model: 3 // Créer 3 points

                                            delegate: Rectangle {
                                                width: 12
                                                height: 12
                                                radius: 6 // Pour faire un cercle
                                                color: "gray"
                                                opacity: 0.5

                                                // Animation de pulsation
                                                SequentialAnimation on y {
                                                    loops: Animation.Infinite
                                                    // Attendre un peu avant de commencer (crée l'effet de vague)
                                                    PauseAnimation { duration: index * 150 }
                                                    // Monter
                                                    NumberAnimation { to: -5; duration: 300; easing.type: Easing.InOutQuad }
                                                    // Redescendre
                                                    NumberAnimation { to: 0; duration: 300; easing.type: Easing.InOutQuad }
                                                    // Pause en bas
                                                    PauseAnimation { duration: 400 }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        // Zone de saisie
                        Rectangle {
                            id: _inputMessageArea
                            Layout.fillWidth: true
                            height: 160
                            color: "white"
                            border.color: borderColor
                            border.width: 1

                            Item {
                                id: _filler
                                width: 10
                                height: 10
                                anchors { top: parent.top ; left: parent.left }
                            }
                            ScrollView {
                                id: scrollView
                                anchors { top: parent.top ; left: _filler.right }
                                height: 150
                                width: parent.width - 120
                                anchors { top: parent.top ; left: parent.left }

                                clip: true

                                ScrollBar.vertical.policy: ScrollBar.AsNeeded

                                TextArea {
                                    id: messageInput
                                    height: 150
                                    width: parent.width - 70
                                    wrapMode: Text.WordWrap
                                    placeholderText: "Saisissez votre message ici..."

                                    Keys.onPressed: (event) => {
                                        if ((event.key === Qt.Key_Return || event.key === Qt.Key_Enter) && (event.modifiers & Qt.ControlModifier)) {
                                            sendMessage();
                                            event.accepted = true;
                                        }
                                    }

                                    onContentHeightChanged: {
                                        scrollView.ScrollBar.vertical.position = 1.0;
                                    }

                                    Component.onCompleted: {
                                        forceActiveFocus()
                                    }
                                }

                            }

                            Button {
                                id: sendButton
                                width: 90
                                height: 80
                                anchors { verticalCenter: parent.verticalCenter ; right: verticalFiller.left }
                                text: "Send\n(Ctrl+Enter)"
                                background: Rectangle {
                                    color: sendButton.enabled ? sendButtonColor : "lightgray"
                                    radius: 6
                                }
                                contentItem: Text {
                                    text: sendButton.text
                                    color: "white"
                                    horizontalAlignment: Text.AlignHCenter
                                    verticalAlignment: Text.AlignVCenter
                                    font.bold: true
                                }

                                onClicked: sendMessage()
                                enabled: messageInput.text.trim().length > 0
                            }
                            Item {
                                id: verticalFiller
                                height: 1
                                width: 10
                                anchors { verticalCenter: parent.verticalCenter ; right: parent.right }
                            }
                        }

                        Frame {
                            id: fileManagementArea
                            Layout.fillWidth: true
                            Layout.preferredHeight: 150
                            Layout.topMargin: 5

                            ColumnLayout {
                                anchors.fill: parent
                                anchors.margins: 5

                                Label {
                                    text: "Attached Files Library"
                                    font.bold: true
                                }

                                ScrollView {
                                    Layout.fillWidth: true
                                    Layout.fillHeight: true

                                    ListView {
                                        id: fileListView
                                        model: _chatManager.chatModel.managedFiles
                                        spacing: 5

                                        delegate: Frame {
                                            width: parent.width
                                            height: 30

                                            RowLayout {
                                                anchors.fill: parent
                                                anchors.leftMargin: 5
                                                anchors.rightMargin: 5

                                                BusyIndicator {
                                                    running: model.status === 0 // ManagedFile.Uploading
                                                    visible: running
                                                }

                                                Label {
                                                    text: "✅"
                                                    visible: model.status === 1 // ManagedFile.Ready
                                                    font.pixelSize: 16
                                                }

                                                Label {
                                                    text: model.fileName
                                                    elide: Text.ElideRight
                                                    Layout.fillWidth: true
                                                }

                                                Button {
                                                    text: "✕"
                                                    flat: true
                                                    onClicked: {
                                                        _chatManager.chatModel.deleteUserFile(index)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }

                                Button {
                                    text: "Add File..."
                                    Layout.alignment: Qt.AlignRight
                                    onClicked: fileDialog.open()
                                }
                            }

                            // Le FileDialog est invisible, il ne s'ouvre que sur appel
                            FileDialog {
                                id: fileDialog
                                title: "Please choose a file to attach"
                                onAccepted: {
                                    _chatManager.chatModel.uploadUserFile(fileDialog.currentFile)
                                }
                            }
                        }
                    }
                }
            }
            // 1.2.2 `_configArea` : Configuration form: IP address of the API endpoint, API Key,
            // Size of the rolling context, directories used for data storage, ...
            // ------------------------------
            // 1.2.2 `_configArea` : Fenêtre de Configuration
            RowLayout {
                id: _configArea
                Layout.fillWidth: true
                Layout.fillHeight: true
                spacing: 10
                visible: _tabBar.currentIndex === 1 // S'assurer que la visibilité est bien gérée
                // Fonction QML pour synchroniser les ComboBoxs de Provider et Model
                function syncProviderModel() {
                    if (!_chatManager.currentConfig) return;

                    // 1. Synchroniser le Provider ComboBox
                    let providerIndex = providerComboBox.model.indexOf(_chatManager.currentConfig.type);
                    providerComboBox.currentIndex = providerIndex;

                    // 2. Charger le modèle des modèles pour ce provider
                    let providerName = providerIndex >= 0 ? providerComboBox.model[providerIndex] : "";
                    modelComboBox.model = _chatManager.modelsForProvider(providerName);

                    // 3. Synchroniser le Model ComboBox
                    let modelIndex = modelComboBox.model.indexOf(_chatManager.currentConfig.modelName);
                    modelComboBox.currentIndex = modelIndex;

                    // CORRECTION: Si le fournisseur est chargé sans modèle (nouvelle config), on choisit le premier
                    if (modelIndex < 0 && modelComboBox.model && modelComboBox.model.length > 0 && !_chatManager.currentConfig.modelName) {
                        modelComboBox.currentIndex = 0;
                        // On déclenche l'action associée pour mettre à jour l'URL et le nom dans la config
                        modelComboBox.onActivated(0);
                    }
                }

                // --- Panneau de gauche : Liste des interlocuteurs ---
                Frame {
                    Layout.preferredWidth: 200
                    Layout.fillHeight: true

                    ColumnLayout {
                        anchors.fill: parent

                        Label {
                            text: "Interlocutors"
                            font.bold: true
                            Layout.alignment: Qt.AlignHCenter
                        }

                        ListView {
                            id: configListView
                            Layout.fillWidth: true
                            Layout.fillHeight: true
                            model: _chatManager? _chatManager.interlocutorNames : ""
                            currentIndex: -1

                            delegate: ItemDelegate {
                                text: modelData
                                width: parent.width
                                highlighted: ListView.isCurrentItem
                                onClicked: {
                                    configListView.currentIndex = index;
                                    _chatManager.selectConfigToEdit(modelData);
                                }
                            }
                        }
                        Button {
                            text: "Add New Interlocutor"
                            Layout.fillWidth: true
                            onClicked: {
                                configListView.currentIndex = -1; // Désélectionner
                                _chatManager.createNewConfig();
                            }
                        }
                    }
                }

                // --- Panneau de droite : Formulaire de configuration ---
                Frame {
                    Layout.fillWidth: true
                    Layout.fillHeight: true

                    // On affiche le formulaire seulement si un item est sélectionné ou en cours de création
                    enabled: _chatManager.currentConfig !== null
                    // Ce bloc écoute le changement de l'objet de configuration C++
                    Connections {
                        target: _chatManager
                        // Ce signal est émis chaque fois qu'on sélectionne un interlocuteur existant
                        // ou qu'on en crée un nouveau.
                        function onCurrentConfigChanged() {
                            if (!_chatManager.currentConfig) return;

                            // 1. Provider
                            providerComboBox.currentIndex = providerComboBox.model.indexOf(_chatManager.currentConfig.type);

                            // 2. Models (on met à jour le modèle AVANT de chercher l'index)
                            var provider = _chatManager.currentConfig.type;
                            if (provider) {
                                modelComboBox.model = _chatManager.modelsForProvider(provider);
                                // MAINTENANT on peut chercher l'index dans le BON modèle
                                modelComboBox.currentIndex = modelComboBox.model.indexOf(_chatManager.currentConfig.modelName);
                            } else {
                                modelComboBox.model = [];
                                modelComboBox.currentIndex = -1;
                            }
                        }
                    }

                    ScrollView {
                        anchors.fill: parent

                        GridLayout {
                            width: parent.width
                            columns: 2

                            Item {
                                id: filler1
                                width: 10
                                height: 10
                            }
                            Item {
                                id: filler2
                                width: 10
                                height: 10
                            }

                            // Le nom (ne peut pas être édité pour un existant pour l'instant)
                            Label { text: qsTr("Name:") }
                            TextField {
                                id: nameField
                                Layout.fillWidth: true
                                text: _chatManager.currentConfig ? _chatManager.currentConfig.name : ""
                                placeholderText: "Unique name (e.g., 'Work Assistant')"
                                // Synchroniser la valeur vers le C++
                                onTextChanged: if (_chatManager.currentConfig) _chatManager.currentConfig.name = text
                            }

                            Label { text: qsTr("Provider:") }
                            ComboBox {
                                id: providerComboBox
                                Layout.fillWidth: true
                                model: _chatManager.availableProviders

                                // Mettre à jour config.type et charge le modèle de la ComboBox suivante.
                                onActivated: (index) => {
                                                 if (!_chatManager.currentConfig) return;

                                                 // 1. Mise à jour du type dans la config C++
                                                 _chatManager.currentConfig.type = model[index];

                                                 // 2. Mise à jour du modèle de la ComboBox des modèles
                                                 modelComboBox.model = _chatManager.modelsForProvider(model[index]);

                                                 // 3. Sélectionner le premier modèle par défaut
                                                 if (modelComboBox.model.length > 0) {
                                                     modelComboBox.currentIndex = 0;
                                                     // Déclencher l'action pour que le C++ mette à jour le nom du modèle et l'URL
                                                     modelComboBox.onActivated(0);
                                                 }
                                             }

                            }

                            // Nouvelle ComboBox pour le Modèle
                            Label { text: qsTr("Model:") }
                            ComboBox {
                                id: modelComboBox
                                Layout.fillWidth: true
                                onActivated: (index) => {
                                                 if (!_chatManager.currentConfig) return;
                                                 // Synchronisation vers le C++ (met à jour modelName et endpointUrl)
                                                 _chatManager.updateConfigWithModel(model[index]);
                                             }
                            }

                            // Clé API
                            Label { text: "API Key:" }
                            TextField {
                                id: apiKeyField
                                Layout.fillWidth: true
                                text: _chatManager.currentConfig ? _chatManager.currentConfig.apiKey : ""
                                placeholderText: "sk-..."
                                echoMode: TextInput.Password
                                onTextChanged: if (_chatManager.currentConfig) _chatManager.currentConfig.apiKey = text
                            }

                            // Endpoint URL
                            Label { text: "Endpoint URL:" }
                            TextField {
                                id: endpointUrlField
                                Layout.fillWidth: true
                                text: _chatManager.currentConfig ? _chatManager.currentConfig.endpointUrl : ""
                                readOnly: true // L'utilisateur n'a plus à s'en soucier !
                                placeholderText: "Auto-filled based on model selection"
                            }

                            // Instructions Personnalisées (System Prompt)
                            Label {
                                text: "Custom Instructions:"
                                Layout.alignment: Qt.AlignTop
                            }
                            TextArea {
                                id: systemPromptArea
                                Layout.fillWidth: true
                                Layout.preferredHeight: 200
                                text: _chatManager && _chatManager.currentConfig ? _chatManager.currentConfig.systemPrompt : ""
                                placeholderText: "You are a helpful assistant..."
                                wrapMode: Text.Wrap
                                onTextChanged: if (_chatManager.currentConfig) _chatManager.currentConfig.systemPrompt = text
                            }

                            // Espace vide pour pousser les boutons en bas
                            Item { Layout.fillHeight: true; Layout.columnSpan: 2 }

                            // Boutons d'action
                            Item {} // Cellule vide
                            RowLayout {
                                Layout.alignment: Qt.AlignRight
                                Button {
                                    text: qsTr("Save Changes")
                                    highlighted: true
                                    onClicked: {
                                        if (_chatManager.saveConfig(_chatManager.currentConfig)) {
                                            // Succès ! On pourrait afficher une notification.
                                            configListView.currentIndex = configListView.model.indexOf(nameField.text)
                                        } else {
                                            // Échec, afficher une erreur.
                                        }
                                    }
                                }
                                Button {
                                    text: "Delete"
                                    // ... logique de suppression avec confirmation ...
                                    // !!! DANGEREUX !!!
                                    // POUR L'INSTANT CA NE FAIT RIEN...
                                    // MAIS DEMANDER DEUX OU TROIS CONFIRMATION CLAIRE AVANT D'EFFACER QUOIQUE CE SOIT !!!
                                }
                                Button {
                                    text: "Reset Session Cost"
                                    onClicked: _chatManager.chatModel.resetTokenCost()
                                }
                            }
                        }
                    }
                }
            }
            // 1.2.3 `_infoArea` : Information page, versions, details, URL of the github, ...
            // ------------------------------
            ColumnLayout {
                id: _infoArea
                visible: true
                width: parent.width
                Layout.fillHeight: true
                Label {
                    text: "Information Window : PLACEHOLDER, TO BE IMPLEMENTED"
                }
            }
        }
    }
}
// End Source File Main.qml
